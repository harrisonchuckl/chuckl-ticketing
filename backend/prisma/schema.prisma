// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  name             String?
  email            String   @unique
  passwordHash     String?
  role             String?  // "admin" | "organiser" etc.

  // Used in code
  organiserSplitBps Int?    // e.g. 1000 == 10%

  orders  Order[]
  shows   Show[]   @relation("UserShows")
}

model Venue {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  name       String
  // Code sometimes selects 'address'. If your DB has address1/address2/city/postcode,
  // you can either keep those and change code, or present a single 'address' field:
  address    String?  // If you already have address1, you can do: address String? @map("address1")

  shows      Show[]
}

model Show {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String?
  description String?
  imageUrl    String?
  date        DateTime

  venueId     String?
  venue       Venue?   @relation(fields: [venueId], references: [id])

  organiserId String?
  organiser   User?    @relation("UserShows", fields: [organiserId], references: [id])

  ticketTypes TicketType[]
  orders      Order[]
  tickets     Ticket[]
}

model TicketType {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  showId        String
  show          Show     @relation(fields: [showId], references: [id])

  name          String
  pricePence    Int
  feePence      Int?
  quantityTotal Int?
  quantitySold  Int?
  maxPerOrder   Int?
  isActive      Boolean  @default(true)
  sortOrder     Int?

  // Code reads 'available' directly from Prisma type
  available     Int?     // <- optional computed-ish field you can set/maintain in code

  tickets       Ticket[]
  orders        Order[]
}

model Order {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  showId           String
  show             Show     @relation(fields: [showId], references: [id])

  userId           String?
  user             User?    @relation(fields: [userId], references: [id])

  ticketTypeId     String?
  ticketType       TicketType? @relation(fields: [ticketTypeId], references: [id])

  // Code expects quantity on Order
  quantity         Int?

  platformFeePence   Int?
  organiserSharePence Int?
  paymentFeePence     Int?
  netPayoutPence      Int?

  tickets          Ticket[]
}

model Ticket {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  showId       String
  show         Show     @relation(fields: [showId], references: [id])

  orderId      String
  order        Order    @relation(fields: [orderId], references: [id])

  ticketTypeId String
  ticketType   TicketType @relation(fields: [ticketTypeId], references: [id])

  seatId       String?
  amountPence  Int
  quantity     Int       @default(1)

  // Fields your code uses in email/scan/services
  serial       String?   @unique
  status       String?   // e.g. "ISSUED" | "SCANNED" | "CANCELLED"
  scannedAt    DateTime?
  holderName   String?
}
