generator client {
  provider      = "prisma-client-js"
  // Include both engine targets so the client works on Debian 11 (OpenSSL 1.1)
  // and Debian 12 (OpenSSL 3.0) runtimes.
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum OrderStatus {
  PENDING
  PAID
  REFUNDED
  CANCELLED
}

enum OrderEmailStatus {
  SENT
  FAILED
  SKIPPED
  UNKNOWN
}

enum OrderAuditAction {
  RESEND_EMAIL
  NOTE_ADDED
  TAGS_UPDATED
  BULK_RESEND_EMAIL
  BULK_TAGS_UPDATED
}

enum SeatStatus {
  AVAILABLE
  HELD
  SOLD
  BLOCKED
}

enum ShowStatus {
  DRAFT
  LIVE
}

enum PlatformRole {
  USER
  PLATFORM_ADMIN
}

enum VenueRole {
  OWNER
  MANAGER
  BOX_OFFICE
  FINANCE
  READ_ONLY
}

enum PromoterStatus {
  PROSPECT
  ACTIVE
  DORMANT
  BLOCKED
}

enum PromoterDocumentStatus {
  MISSING
  UPLOADED
  EXPIRED
  APPROVED
}

enum PromoterDocumentType {
  PRS_CERTIFICATE
  PPL_MUSIC_LICENSING
  PUBLIC_LIABILITY_INSURANCE
  RISK_ASSESSMENT
  TECH_SPEC
  MARKETING_SPEC
  ACCESSIBILITY_INFO
  BRANDING_GUIDELINES
  OTHER
}

enum PromoterActivityType {
  CREATED
  UPDATED
  CONTACT_ADDED
  CONTACT_UPDATED
  CONTACT_REMOVED
  DOCUMENT_UPLOADED
  DOCUMENT_UPDATED
  DOCUMENT_REMOVED
}

enum MarketingConsentStatus {
  SUBSCRIBED
  UNSUBSCRIBED
  TRANSACTIONAL_ONLY
  BOUNCED
  COMPLAINED
}

enum MarketingLawfulBasis {
  EXPLICIT_OPT_IN
  SOFT_OPT_IN
  UNKNOWN
}

enum MarketingConsentSource {
  CHECKOUT
  MANUAL_IMPORT
  ADMIN_EDIT
  API
}

enum MarketingSuppressionType {
  UNSUBSCRIBE
  HARD_BOUNCE
  SPAM_COMPLAINT
}

enum MarketingCampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  CANCELLED
}

enum MarketingRecipientStatus {
  PENDING
  SENT
  FAILED
  SKIPPED_SUPPRESSED
}

enum MarketingEmailEventType {
  DELIVERED
  BOUNCE
  COMPLAINT
  OPEN
  CLICK
  UNSUBSCRIBE
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name         String?
  email        String       @unique
  passwordHash String?
  role         String?
  platformRole PlatformRole @default(USER)

  organiserSplitBps Int?

  // ✅ Password reset fields
  resetTokenHash        String?   @db.Text
  resetTokenExpiresAt   DateTime?
  resetTokenRequestedAt DateTime?
  resetTokenUsedAt      DateTime?

  orders         Order[]
  showsOrganised Show[]   @relation("OrganiserShows")
  tickets        Ticket[]
  orderNotes     OrderNote[] @relation("OrderNoteAuthor")
  orderAuditLogs OrderAuditLog[] @relation("OrderAuditActor")

  venueMemberships    VenueMember[]
  invitedVenueMembers VenueMember[] @relation("VenueInviter")
  venueInvitesCreated VenueInvite[] @relation("VenueInviteCreatedBy")

  promotersOwned            Promoter[]         @relation("PromoterOwner")
  promoterDocumentsUploaded PromoterDocument[] @relation("PromoterDocumentUploader")
  promoterActivities        PromoterActivity[] @relation("PromoterActivityAuthor")

  // Slug history for organiser show URLs
  showSlugHistory ShowSlugHistory[]

  // --- organiser business details (optional) ---
  companyName   String?
  tradingName   String?
  companyNumber String?
  vatNumber     String?
  phone         String?
  addressLine1  String?
  addressLine2  String?
  city          String?
  county        String?
  postcode      String?
  country       String?

  // --- storefront (must be unique per organiser) ---
  storefrontSlug String? @unique

  marketingContacts    MarketingContact[]
  marketingTags        MarketingTag[]
  marketingTemplates   MarketingTemplate[]
  marketingSegments    MarketingSegment[]
  marketingCampaigns   MarketingCampaign[] @relation("MarketingCampaignCreatedBy")
  marketingCampaignsAsTenant MarketingCampaign[] @relation("MarketingCampaignTenant")
  marketingSuppressions MarketingSuppression[]
}

model AccessRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String?
  email       String   @unique
  companyName String?

  tokenHash String   @unique @db.Text
  approvedAt DateTime?
  approvedBy String?
}

model Venue {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name     String
  address  String?
  city     String?
  postcode String?
  capacity Int?

  imageUrl        String?
  contactName     String?
  contactEmail    String?
  contactPhone    String?
  ticketContraBps Int?
  bookingFeeBps   Int?
  spaces          String[] @default([])
  seatingMaps     String[] @default([])

  shows    Show[]
  seatMaps SeatMap[]

  members      VenueMember[]
  venueInvites VenueInvite[] @relation("VenueInviteVenue")
}

model Promoter {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String @unique
  tradingName String?
  email       String?
  phone       String?

  companyNumber String?
  vatNumber     String?

  addressLine1 String?
  addressLine2 String?
  city         String?
  county       String?
  postcode     String?
  country      String?

  status PromoterStatus @default(PROSPECT)
  notes  String?

  ownerId String?
  owner   User? @relation("PromoterOwner", fields: [ownerId], references: [id])

  contacts   PromoterContact[]
  documents  PromoterDocument[]
  activities PromoterActivity[]
}

model PromoterContact {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  promoterId String
  promoter   Promoter @relation(fields: [promoterId], references: [id])

  name  String
  role  String?
  email String?
  phone String?
  tags  String[] @default([])

  isPrimaryFinance   Boolean @default(false)
  isPrimaryMarketing Boolean @default(false)

  @@index([promoterId])
}

model PromoterDocument {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  promoterId String
  promoter   Promoter @relation(fields: [promoterId], references: [id])

  venueId String?

  type      PromoterDocumentType
  title     String
  fileUrl   String
  fileName  String?
  mime      String?
  size      Int?
  expiresAt DateTime?
  status    PromoterDocumentStatus @default(UPLOADED)

  uploadedByUserId String?
  uploadedBy       User? @relation("PromoterDocumentUploader", fields: [uploadedByUserId], references: [id])

  @@index([promoterId])
}

model PromoterActivity {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  promoterId String
  promoter   Promoter @relation(fields: [promoterId], references: [id])

  type     PromoterActivityType
  metadata Json?

  createdByUserId String?
  createdBy       User? @relation("PromoterActivityAuthor", fields: [createdByUserId], references: [id])

  @@index([promoterId])
}

model VenueInvite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venueId     String
  email       String
  role        VenueRole @default(READ_ONLY)
  permissions String[]  @default([])

  tokenHash String   @db.Text
  expiresAt DateTime

  createdById String?
  createdBy   User?   @relation("VenueInviteCreatedBy", fields: [createdById], references: [id])

  revokedAt  DateTime?
  acceptedAt DateTime?

  venue Venue @relation("VenueInviteVenue", fields: [venueId], references: [id])

  @@unique([tokenHash])
  @@index([venueId])
  @@index([email])
}

model VenueMember {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venueId String
  userId  String

  role VenueRole @default(READ_ONLY)

  // Tick-box system for MVP, expandable later:
  // e.g. ["FINANCE_VIEW", "FINANCE_EDIT_PAYOUTS", "EVENT_CREATE", ...]
  permissions String[] @default([])

  invitedByUserId String?
  invitedAt       DateTime?
  acceptedAt      DateTime?

  venue Venue @relation(fields: [venueId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  invitedBy User? @relation("VenueInviter", fields: [invitedByUserId], references: [id])

  @@unique([venueId, userId])
  @@index([venueId])
  @@index([userId])
}

model Show {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String?
  description String?
  imageUrl    String?
  date        DateTime
  endDate     DateTime?

  doorsOpenTime String?
  ageGuidance   String?
  endTimeNote   String?

  eventType        String?
  eventCategory    String?
  additionalImages String[] @default([])
  tags             String[] @default([])
  accessibility    Json?

  status      ShowStatus @default(DRAFT)
  publishedAt DateTime?
  // --- pretty URL slug (generated on publish / title change) ---
  slug        String?

  usesAllocatedSeating Boolean?
  activeSeatMapId      String?

  /// Overall show capacity across all ticket types.
  /// If set, checkout will never allow more than this total quantity sold/reserved.
  /// If null, capacity is derived from ticket allocations (unlimited if any allocation is blank).
  showCapacity Int?

  venueId     String?
  organiserId String?

  venue     Venue? @relation(fields: [venueId], references: [id])
  organiser User?  @relation("OrganiserShows", fields: [organiserId], references: [id])

  ticketTypes TicketType[]
  tickets     Ticket[]
  orders      Order[]
  seatMaps    SeatMap[]
  allocations ExternalAllocation[]

  // Slug history for public URL redirects
  slugHistory ShowSlugHistory[]

  @@index([venueId])
  @@index([organiserId])
  @@index([date])
}

model ShowSlugHistory {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  organiserId String
  showId      String
  slug        String

  organiser User @relation(fields: [organiserId], references: [id])
  show      Show @relation(fields: [showId], references: [id])

  @@unique([organiserId, slug])
  @@index([showId])
}

model TicketType {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name       String
  pricePence Int

  /// Booking fee charged on top of face value (per ticket, in pence).
  /// Must be >= tier minimum for this ticket price (enforced server-side).
  bookingFeePence Int?

  /// When this ticket should first be available to buy
  onSaleAt  DateTime?
  /// When this ticket should stop being available
  offSaleAt DateTime?

  /// Numeric availability used by routes (e.g. comparisons like > 0)
  available Int?

  showId String
  show   Show   @relation(fields: [showId], references: [id])

  tickets Ticket[]
  orders  Order[]
}

model Order {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  amountPence         Int
  platformFeePence    Int?
  organiserSharePence Int?
  paymentFeePence     Int?
  netPayoutPence      Int?

  stripeId String?
  status   OrderStatus @default(PENDING)
  email    String?
  // ✅ Captured from Stripe Checkout custom_fields
  buyerFirstName String?
  buyerLastName  String?
  buyerPostcode  String?

  /// Some routes read a top-level quantity directly on the order
  quantity Int?

  tags               String[]         @default([])
  emailDeliveryStatus OrderEmailStatus?
  emailDeliveryAt     DateTime?
  emailDeliveryError  String?
  emailPdfAttached    Boolean?

  showId       String
  userId       String?
  ticketTypeId String?

  show       Show        @relation(fields: [showId], references: [id])
  user       User?       @relation(fields: [userId], references: [id])
  ticketType TicketType? @relation(fields: [ticketTypeId], references: [id])

  tickets Ticket[]
  refunds Refund[]
  notes   OrderNote[]
  auditLogs OrderAuditLog[]

  seatsCsv                String? @db.Text
  stripeCheckoutSessionId String? @db.VarChar(255)

  @@index([createdAt])
  @@index([status])
  @@index([showId])
  @@index([ticketTypeId])
  @@index([email])
  @@index([stripeId])
  @@index([stripeCheckoutSessionId])
  @@index([emailDeliveryStatus])
}

model MarketingContact {
  id        String   @id @default(cuid())
  tenantId  String
  email     String
  firstName String?
  lastName  String?
  phone     String?
  town      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    User @relation(fields: [tenantId], references: [id])


  consents   MarketingConsent[]
  tags       MarketingContactTag[]
  recipients MarketingCampaignRecipient[]
  events     MarketingEmailEvent[]

  @@unique([tenantId, email])
  @@index([tenantId])
}

model MarketingConsent {
  id                String                 @id @default(cuid())
  tenantId          String
  contactId         String
  status            MarketingConsentStatus
  lawfulBasis       MarketingLawfulBasis
  source            MarketingConsentSource
  capturedAt        DateTime
  capturedIp        String?
  capturedUserAgent String?

  contact MarketingContact @relation(fields: [contactId], references: [id])

  @@unique([tenantId, contactId])
  @@index([tenantId])
}

model MarketingSuppression {
  id        String                 @id @default(cuid())
  tenantId  String
  email     String
  type      MarketingSuppressionType
  reason    String?
  createdAt DateTime               @default(now())

  tenant User @relation(fields: [tenantId], references: [id])

  @@index([tenantId, email])
  @@index([tenantId])
}

model MarketingTag {
  id       String @id @default(cuid())
  tenantId String
  name     String

  tenant   User @relation(fields: [tenantId], references: [id])
  contacts MarketingContactTag[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

model MarketingContactTag {
  tenantId  String
  contactId String
  tagId     String

  contact MarketingContact @relation(fields: [contactId], references: [id])
  tag     MarketingTag     @relation(fields: [tagId], references: [id])

  @@id([contactId, tagId])
  @@index([tenantId])
}

model MarketingTemplate {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  subject   String
  fromName  String
  fromEmail String
  replyTo   String?
  mjmlBody  String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    User @relation(fields: [tenantId], references: [id])
  campaigns MarketingCampaign[]

  @@index([tenantId])
}

model MarketingSegment {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  description String?
  rules       Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant    User @relation(fields: [tenantId], references: [id])
  campaigns MarketingCampaign[]

  @@index([tenantId])
}

model MarketingCampaign {
  id              String                 @id @default(cuid())
  tenantId        String
  name            String
  templateId      String
  segmentId       String
  status          MarketingCampaignStatus @default(DRAFT)
  scheduledFor    DateTime?
  createdByUserId String
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt

  tenant     User             @relation(fields: [tenantId], references: [id])
  template   MarketingTemplate @relation(fields: [templateId], references: [id])
  segment    MarketingSegment  @relation(fields: [segmentId], references: [id])
  createdBy  User             @relation("MarketingCampaignCreatedBy", fields: [createdByUserId], references: [id])
  recipients MarketingCampaignRecipient[]
  events     MarketingEmailEvent[]

  @@index([tenantId])
}

model MarketingCampaignRecipient {
  id         String                  @id @default(cuid())
  tenantId   String
  campaignId String
  contactId  String
  email      String
  status     MarketingRecipientStatus @default(PENDING)
  errorText  String?
  sentAt     DateTime?
  createdAt  DateTime               @default(now())

  campaign MarketingCampaign @relation(fields: [campaignId], references: [id])
  contact  MarketingContact  @relation(fields: [contactId], references: [id])

  @@unique([tenantId, campaignId, contactId])
  @@index([tenantId, campaignId])
}

model MarketingEmailEvent {
  id         String                 @id @default(cuid())
  tenantId   String
  campaignId String
  contactId  String?
  email      String
  type       MarketingEmailEventType
  meta       Json?
  createdAt  DateTime               @default(now())

  campaign MarketingCampaign @relation(fields: [campaignId], references: [id])
  contact  MarketingContact? @relation(fields: [contactId], references: [id])

  @@index([tenantId, campaignId])
  @@index([tenantId])
}

model OrderNote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  body String

  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  createdById String?
  createdBy   User?   @relation("OrderNoteAuthor", fields: [createdById], references: [id])

  @@index([orderId])
  @@index([createdAt])
}

model OrderAuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  action OrderAuditAction
  metadata Json?

  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  actorId String?
  actor   User?   @relation("OrderAuditActor", fields: [actorId], references: [id])

  @@index([orderId])
  @@index([createdAt])
  @@index([actorId])
}

model Refund {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// Kept for routes that read `amount`
  amount      Int
  /// Some code references `amountPence`; keep both for compatibility
  amountPence Int?
  reason      String?
  /// E.g. Stripe refund id or processor reference
  processorId String?
  /// Some routes refer to this key
  stripeId    String?

  orderId String
  order   Order  @relation(fields: [orderId], references: [id])
}

model Ticket {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  showId      String
  amountPence Int
  quantity    Int    @default(1)

  orderId      String
  ticketTypeId String

  status     String?
  seatId     String?
  seatRef    String?
  serial     String?   @unique
  scannedAt  DateTime?
  holderName String?

  show       Show       @relation(fields: [showId], references: [id])
  order      Order      @relation(fields: [orderId], references: [id])
  ticketType TicketType @relation(fields: [ticketTypeId], references: [id])
  userId     String?
  user       User?      @relation(fields: [userId], references: [id])
}

model SeatMap {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  version   Int     @default(1)
  isDefault Boolean @default(false)

  // NEW FIELDS
  isTemplate      Boolean @default(false)
  createdByUserId String?

  layout Json?

  showId  String
  venueId String?

  show        Show                 @relation(fields: [showId], references: [id])
  venue       Venue?               @relation(fields: [venueId], references: [id])
  seats       Seat[]
  zones       Zone[]
  allocations ExternalAllocation[]
}

model Zone {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  label String
  level String?

  seatMapId String
  seatMap   SeatMap @relation(fields: [seatMapId], references: [id])

  seats Seat[]
}

model Seat {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seatMapId       String
  seatMap         SeatMap          @relation(fields: [seatMapId], references: [id])
  allocationSeats AllocationSeat[]

  /// Basic coordinates
  row    String
  number Int

  /// Denormalised / optional fields referenced by routes
  rowLabel   String?
  seatNumber Int?
  label      String?
  kind       String?
  level      String?

  status SeatStatus @default(AVAILABLE)
  zoneId String?
  zone   Zone?      @relation(fields: [zoneId], references: [id])
}

model ExternalAllocation {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  showId           String
  seatMapId        String?
  source           String
  label            String?
  externalPlatform String?
  contactEmail     String?
  quantity         Int

  show    Show             @relation(fields: [showId], references: [id])
  seatMap SeatMap?         @relation(fields: [seatMapId], references: [id])
  seats   AllocationSeat[]
}

model AllocationSeat {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  allocationId String
  seatId       String
  rowLabel     String?
  seatNumber   Int?
  level        String?

  allocation ExternalAllocation @relation(fields: [allocationId], references: [id])
  seat       Seat               @relation(fields: [seatId], references: [id])
}
