generator client {
  provider      = "prisma-client-js"
  // Include both engine targets so the client works on Debian 11 (OpenSSL 1.1)
  // and Debian 12 (OpenSSL 3.0) runtimes.
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum OrderStatus {
  PENDING
  PAID
  REFUNDED
  CANCELLED
}

enum SeatStatus {
  AVAILABLE
  HELD
  SOLD
  BLOCKED
}

enum ShowStatus {
  DRAFT
  LIVE
}

enum PlatformRole {
  USER
  PLATFORM_ADMIN
}

enum VenueRole {
  OWNER
  MANAGER
  BOX_OFFICE
  FINANCE
  READ_ONLY
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name         String?
  email        String       @unique
  passwordHash String?
  role         String?
  platformRole PlatformRole @default(USER)

  organiserSplitBps Int?

  // ✅ Password reset fields
  resetTokenHash        String?   @db.Text
  resetTokenExpiresAt   DateTime?
  resetTokenRequestedAt DateTime?
  resetTokenUsedAt      DateTime?

  orders         Order[]
  showsOrganised Show[]   @relation("OrganiserShows")
  tickets        Ticket[]

  venueMemberships    VenueMember[]
  invitedVenueMembers VenueMember[] @relation("VenueInviter")
  venueInvitesCreated VenueInvite[] @relation("VenueInviteCreatedBy")

  // Slug history for organiser show URLs
  showSlugHistory ShowSlugHistory[]

  // --- organiser business details (optional) ---
  companyName   String?
  tradingName   String?
  companyNumber String?
  vatNumber     String?
  phone         String?
  addressLine1  String?
  addressLine2  String?
  city          String?
  county        String?
  postcode      String?
  country       String?

  // --- storefront (must be unique per organiser) ---
  storefrontSlug String? @unique
}

model Venue {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name     String
  address  String?
  city     String?
  postcode String?
  capacity Int?

  imageUrl        String?
  contactName     String?
  contactEmail    String?
  contactPhone    String?
  ticketContraBps Int?
  bookingFeeBps   Int?
  spaces          String[] @default([])
  seatingMaps     String[] @default([])

  shows    Show[]
  seatMaps SeatMap[]

  members      VenueMember[]
  venueInvites VenueInvite[] @relation("VenueInviteVenue")
}

model VenueInvite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venueId     String
  email       String
  role        VenueRole @default(READ_ONLY)
  permissions String[]  @default([])

  tokenHash String   @db.Text
  expiresAt DateTime

  createdById String?
  createdBy   User?   @relation("VenueInviteCreatedBy", fields: [createdById], references: [id])

  revokedAt  DateTime?
  acceptedAt DateTime?

  venue Venue @relation("VenueInviteVenue", fields: [venueId], references: [id])

  @@unique([tokenHash])
  @@index([venueId])
  @@index([email])
}

model VenueMember {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  venueId String
  userId  String

  role VenueRole @default(READ_ONLY)

  // Tick-box system for MVP, expandable later:
  // e.g. ["FINANCE_VIEW", "FINANCE_EDIT_PAYOUTS", "EVENT_CREATE", ...]
  permissions String[] @default([])

  invitedByUserId String?
  invitedAt       DateTime?
  acceptedAt      DateTime?

  venue Venue @relation(fields: [venueId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  invitedBy User? @relation("VenueInviter", fields: [invitedByUserId], references: [id])

  @@unique([venueId, userId])
  @@index([venueId])
  @@index([userId])
}

model Show {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String?
  description String?
  imageUrl    String?
  date        DateTime
  endDate     DateTime?

  doorsOpenTime String?
  ageGuidance   String?
  endTimeNote   String?

  eventType        String?
  eventCategory    String?
  additionalImages String[] @default([])
  tags             String[] @default([])
  accessibility    Json?

  status      ShowStatus @default(DRAFT)
  publishedAt DateTime?
  // --- pretty URL slug (generated on publish / title change) ---
  slug        String?

  usesAllocatedSeating Boolean?
  activeSeatMapId      String?

  /// Overall show capacity across all ticket types.
  /// If set, checkout will never allow more than this total quantity sold/reserved.
  /// If null, capacity is derived from ticket allocations (unlimited if any allocation is blank).
  showCapacity Int?

  venueId     String?
  organiserId String?

  venue     Venue? @relation(fields: [venueId], references: [id])
  organiser User?  @relation("OrganiserShows", fields: [organiserId], references: [id])

  ticketTypes TicketType[]
  tickets     Ticket[]
  orders      Order[]
  seatMaps    SeatMap[]
  allocations ExternalAllocation[]

  // Slug history for public URL redirects
  slugHistory ShowSlugHistory[]
}

model ShowSlugHistory {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  organiserId String
  showId      String
  slug        String

  organiser User @relation(fields: [organiserId], references: [id])
  show      Show @relation(fields: [showId], references: [id])

  @@unique([organiserId, slug])
  @@index([showId])
}

model TicketType {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name       String
  pricePence Int

  /// Booking fee charged on top of face value (per ticket, in pence).
  /// Must be >= tier minimum for this ticket price (enforced server-side).
  bookingFeePence Int?

  /// When this ticket should first be available to buy
  onSaleAt  DateTime?
  /// When this ticket should stop being available
  offSaleAt DateTime?

  /// Numeric availability used by routes (e.g. comparisons like > 0)
  available Int?

  showId String
  show   Show   @relation(fields: [showId], references: [id])

  tickets Ticket[]
  orders  Order[]
}

model Order {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  amountPence         Int
  platformFeePence    Int?
  organiserSharePence Int?
  paymentFeePence     Int?
  netPayoutPence      Int?

  stripeId String?
  status   OrderStatus @default(PENDING)
  email    String?
  // ✅ Captured from Stripe Checkout custom_fields
  buyerFirstName String?
  buyerLastName  String?
  buyerPostcode  String?

  /// Some routes read a top-level quantity directly on the order
  quantity Int?

  showId       String
  userId       String?
  ticketTypeId String?

  show       Show        @relation(fields: [showId], references: [id])
  user       User?       @relation(fields: [userId], references: [id])
  ticketType TicketType? @relation(fields: [ticketTypeId], references: [id])

  tickets Ticket[]
  refunds Refund[]

  seatsCsv                String? @db.Text
  stripeCheckoutSessionId String? @db.VarChar(255)
}

model Refund {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// Kept for routes that read `amount`
  amount      Int
  /// Some code references `amountPence`; keep both for compatibility
  amountPence Int?
  reason      String?
  /// E.g. Stripe refund id or processor reference
  processorId String?
  /// Some routes refer to this key
  stripeId    String?

  orderId String
  order   Order  @relation(fields: [orderId], references: [id])
}

model Ticket {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  showId      String
  amountPence Int
  quantity    Int    @default(1)

  orderId      String
  ticketTypeId String

  status     String?
  seatId     String?
  seatRef    String?
  serial     String?   @unique
  scannedAt  DateTime?
  holderName String?

  show       Show       @relation(fields: [showId], references: [id])
  order      Order      @relation(fields: [orderId], references: [id])
  ticketType TicketType @relation(fields: [ticketTypeId], references: [id])
  userId     String?
  user       User?      @relation(fields: [userId], references: [id])
}

model SeatMap {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  version   Int     @default(1)
  isDefault Boolean @default(false)

  // NEW FIELDS
  isTemplate      Boolean @default(false)
  createdByUserId String?

  layout Json?

  showId  String
  venueId String?

  show        Show                 @relation(fields: [showId], references: [id])
  venue       Venue?               @relation(fields: [venueId], references: [id])
  seats       Seat[]
  zones       Zone[]
  allocations ExternalAllocation[]
}

model Zone {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  label String
  level String?

  seatMapId String
  seatMap   SeatMap @relation(fields: [seatMapId], references: [id])

  seats Seat[]
}

model Seat {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seatMapId       String
  seatMap         SeatMap          @relation(fields: [seatMapId], references: [id])
  allocationSeats AllocationSeat[]

  /// Basic coordinates
  row    String
  number Int

  /// Denormalised / optional fields referenced by routes
  rowLabel   String?
  seatNumber Int?
  label      String?
  kind       String?
  level      String?

  status SeatStatus @default(AVAILABLE)
  zoneId String?
  zone   Zone?      @relation(fields: [zoneId], references: [id])
}

model ExternalAllocation {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  showId           String
  seatMapId        String?
  source           String
  label            String?
  externalPlatform String?
  contactEmail     String?
  quantity         Int

  show    Show             @relation(fields: [showId], references: [id])
  seatMap SeatMap?         @relation(fields: [seatMapId], references: [id])
  seats   AllocationSeat[]
}

model AllocationSeat {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  allocationId String
  seatId       String
  rowLabel     String?
  seatNumber   Int?
  level        String?

  allocation ExternalAllocation @relation(fields: [allocationId], references: [id])
  seat       Seat               @relation(fields: [seatId], references: [id])
}
